#!/usr/bin/env bash
# extrair_conteudo.sh ‚Äî Extrai o conte√∫do de arquivos para um arquivo texto
# Compat√≠vel com bash >= 3.2 (mantendo portabilidade para macOS e Linux)
# -----------------------------------------------------------------------------
# PRINCIPAIS MELHORIAS:
# - Separa√ß√£o clara de responsabilidades (parsing, valida√ß√£o, descoberta, filtro, processamento, sa√≠da).
# - Remo√ß√£o de loops duplicados envolvendo `find` (DRY).
# - Nomes de vari√°veis e fun√ß√µes em portugu√™s, descritivos e coerentes.
# - Coment√°rios extensos em portugu√™s, explicando cada etapa.
# - Ajuda (help) detalhada, com exemplos reais de uso e dicas.
# - Mesma l√≥gica essencial, sem perda de funcionalidades e sem quebras de compatibilidade.
# - Tratamento consistente de exclus√µes, extens√µes, pasta base e caminhos relativos/absolutos.
# - ‚ÄúPol√≠tica de log‚Äù unificada (info/sucesso/aviso/erro/ignorado).
# - Mantida a decis√£o de ignorar bin√°rios e arquivos sem permiss√£o de leitura.
# -----------------------------------------------------------------------------

extrair_conteudo() {
  # =============================[ Configura√ß√£o Geral ]=============================
  # Usamos apenas 'pipefail' para melhorar diagn√≥sticos em pipelines
  # (n√£o utilizamos 'set -e' para n√£o alterar o comportamento de continua√ß√£o em erros).
  set -o pipefail

  # ===============================[ Ajuda/Manual ]================================
  mostrar_ajuda() {
    # Ajuda longa e detalhada, com exemplos pr√°ticos.
    # Mant√©m compatibilidade com a op√ß√£o --help/-h do script original.
    cat <<'EOF'
üìÅ extrair_conteudo ‚Äî Extrai o conte√∫do de arquivos texto para um arquivo .txt

üí° O que faz?
  Varre um diret√≥rio (atual ou informado) e gera um arquivo .txt contendo blocos de:
    ==============================...
    INICIO: /caminho/arquivo.ext
    ==============================...
    <conte√∫do do arquivo>
    ==============================...
    FIM: /caminho/arquivo.ext
    ==============================...

  Bin√°rios s√£o ignorados; arquivos sem permiss√£o s√£o avisados e pulados.

üìã USO:
  extrair_conteudo [OP√á√ïES]                        # Processa todos os arquivos do diret√≥rio atual
  extrair_conteudo [OP√á√ïES] [ARQUIVOS...]          # Processa arquivos espec√≠ficos do diret√≥rio atual
  extrair_conteudo [OP√á√ïES] [CAMINHO]              # Processa todos os arquivos do caminho informado
  extrair_conteudo [OP√á√ïES] [CAMINHO] [ARQS...]    # Processa arquivos espec√≠ficos do caminho informado

üéØ OP√á√ïES:
  -h, --help                   Mostra esta ajuda detalhada
  -o, --output ARQUIVO         Define o arquivo de sa√≠da. Padr√£o: "conteudo_arquivos.txt" na pasta processada
                               ‚Ä¢ Aceita caminho absoluto (/‚Ä¶/saida.txt) ou relativo √† pasta processada (ex.: logs/saida.txt)
  -r, --recursive              Varre recursivamente subdiret√≥rios
  --ext LISTA                  Filtra por extens√µes (apenas quando N√ÉO h√° arquivos espec√≠ficos).
                               Voc√™ pode:
                                 --ext .rb,.erb,.html     # v√≠rgulas separam itens
                                 --ext .rb --ext .erb     # pode repetir a flag
                               Observa√ß√µes:
                                 - O ponto inicial √© opcional (".rb" ~ "rb")
                                 - Sem --ext => aceita TODAS as extens√µes
  --exclude LISTA | -x LISTA   Exclui por nome/caminho/padr√£o (aplica-se em todos os modos).
                               Aceita v√≠rgulas e pode repetir a flag. Para globs, use aspas:
                                 --exclude show.html.erb
                                 --exclude '*/pessoas/show.html.erb'
                                 --exclude '_*.jbuilder,*.bak'
                               Como a exclus√£o √© avaliada?
                                 - Compara contra o basename (nome do arquivo) e contra o caminho completo.
                                 - Tamb√©m considera correspond√™ncia de caminho do tipo "*/padrao".
  --sep-width N                Largura M√çNIMA do separador (ex.: 120). Se o cabe√ßalho/rodap√© for maior, aumenta.
  --sep-char PADRAO            Padr√£o do separador. Padr√£o: "="
                               Exemplos: --sep-char '#' | --sep-char '=-' | --sep-char '‚îÄ'

üß≠ COMO O SCRIPT DECIDE O QUE PROCESSAR?
  1) Sem arquivos espec√≠ficos:
     ‚Ä¢ Se sem --ext            => Todos os arquivos do n√≠vel atual (ou recursivo com -r)
     ‚Ä¢ Se com --ext            => Apenas os que combinarem com as extens√µes informadas
     ‚Ä¢ Sempre aplica --exclude
  2) Com arquivos espec√≠ficos:
     ‚Ä¢ Tenta cada nome diretamente, depois tenta "pasta_base/<nome>"
     ‚Ä¢ Se -r, tamb√©m procura recursivamente por basename correspondente
     ‚Ä¢ Sempre aplica --exclude

üìä SA√çDA:
  - Cria um arquivo texto com o conte√∫do concatenado dos arquivos processados.
  - Mensagens de progresso s√£o impressas no terminal.

üß™ EXEMPLOS:
  # 1) Todos os arquivos do diret√≥rio atual
  extrair_conteudo

  # 2) Somente .rb e .erb (n√≠vel atual)
  extrair_conteudo --ext .rb,.erb

  # 3) Recursivo em "app", excluindo tempor√°rios e .bak
  extrair_conteudo -r app --exclude '*.tmp,*.bak'

  # 4) Recursivo com sa√≠da customizada em subpasta
  extrair_conteudo -r --output resultados/saida.txt

  # 5) Somente arquivos espec√≠ficos no diret√≥rio atual
  extrair_conteudo Gemfile README.md

  # 6) Arquivos espec√≠ficos dentro de uma pasta, com busca recursiva de basenames
  extrair_conteudo -r app pessoas_controller.rb application.rb

  # 7) Separador personalizado
  extrair_conteudo --sep-width 120 --sep-char '=-'

  # 8) Excluindo por caminho completo
  extrair_conteudo -r --exclude '*/pessoas/show.html.erb'

‚ö†Ô∏è DICAS:
  - Use aspas ao passar globs em --exclude para o shell n√£o expandir antes.
  - Bin√°rios s√£o detectados e pulados automaticamente.
  - O arquivo de sa√≠da nunca √© inclu√≠do na pr√≥pria extra√ß√£o.

EOF
  }

  # ==========================[ Logging (mensagens) ]==============================
  # Centraliza estilo e emojis; facilita manuten√ß√£o e consist√™ncia.
  log_info() { printf '‚ÑπÔ∏è  %s\n' "$*"; }
  log_sucesso() { printf '‚úÖ %s\n' "$*"; }
  log_aviso() { printf '‚ö†Ô∏è  %s\n' "$*"; }
  log_erro() { printf '‚ùå %s\n' "$*"; }
  log_ignorado() { printf 'üö´ %s\n' "$*"; }

  # ===========================[ Vari√°veis de estado ]=============================
  # Todas locais ao escopo da fun√ß√£o principal.
  local recursivo=false       # -r / --recursive
  local -a lista_extensoes=() # --ext (somente quando n√£o h√° arquivos espec√≠ficos)
  local -a lista_exclusoes=() # --exclude / -x
  local nome_saida=""         # -o / --output (pode ser relativo ou absoluto)
  local -a posicionais=()     # argumentos posicionais (pasta base e/ou arquivos)
  local largura_sep=0         # 0 = adaptativo; >0 = largura m√≠nima
  local padrao_sep="="        # padr√£o do separador

  # ===========================[ Parse de argumentos ]=============================
  # Mant√©m sem uso de getopt para compatibilidade ampla (bash <= 3.2).
  while [[ $# -gt 0 ]]; do
    case "$1" in
    -h | --help | -help | --h)
      mostrar_ajuda
      return 0
      ;;
    -r | --recursive)
      recursivo=true
      shift
      ;;
    -o | --output)
      [[ -n "${2-}" ]] || {
        log_erro "Faltou o nome ap√≥s $1"
        return 1
      }
      nome_saida="$2"
      shift 2
      ;;
    --ext)
      [[ -n "${2-}" ]] || {
        log_erro "Faltou a lista ap√≥s --ext"
        return 1
      }
      local IFS=',' item
      for item in $2; do
        item="${item//[[:space:]]/}"
        [[ -z "$item" ]] && continue
        [[ "$item" == .* ]] || item=".$item" # garante ponto inicial
        lista_extensoes+=("$item")
      done
      shift 2
      ;;
    --exclude | -x)
      [[ -n "${2-}" ]] || {
        log_erro "Faltou a lista ap√≥s $1"
        return 1
      }
      local IFS=',' padrao
      for padrao in $2; do
        padrao="${padrao//[[:space:]]/}"
        [[ -z "$padrao" ]] && continue
        lista_exclusoes+=("$padrao")
      done
      shift 2
      ;;
    --sep-width)
      [[ -n "${2-}" ]] || {
        log_erro "Faltou o n√∫mero ap√≥s --sep-width"
        return 1
      }
      [[ "$2" =~ ^[0-9]+$ ]] || {
        log_erro "--sep-width precisa ser inteiro n√£o-negativo"
        return 1
      }
      largura_sep="$2"
      shift 2
      ;;
    --sep-char)
      [[ -n "${2-}" ]] || {
        log_erro "Faltou o padr√£o ap√≥s --sep-char"
        return 1
      }
      padrao_sep="$2"
      shift 2
      ;;
    --)
      shift
      break
      ;;
    -*)
      log_aviso "Op√ß√£o desconhecida: $1"
      printf "    Use --help para ver o uso.\n"
      return 1
      ;;
    *)
      posicionais+=("$1")
      shift
      ;;
    esac
  done
  # Se ainda houver argumentos (ap√≥s '--'), adiciona aos posicionais
  if [[ $# -gt 0 ]]; then posicionais+=("$@"); fi

  # ==========================[ Pasta base & espec√≠ficos ]=========================
  # Regras:
  # - Se nenhum posicional => pasta base = diret√≥rio atual
  # - Se o primeiro posicional for diret√≥rio => √© a pasta base; os demais s√£o espec√≠ficos
  # - Caso contr√°rio => pasta base = atual; todos os posicionais s√£o espec√≠ficos
  local pasta_base
  local -a arquivos_especificos=()
  if [[ ${#posicionais[@]} -eq 0 ]]; then
    pasta_base="$(pwd)"
  else
    if [[ -d "${posicionais[0]}" ]]; then
      pasta_base="${posicionais[0]}"
      posicionais=("${posicionais[@]:1}")
      arquivos_especificos=("${posicionais[@]}")
    else
      pasta_base="$(pwd)"
      arquivos_especificos=("${posicionais[@]}")
    fi
  fi

  if [[ ! -d "$pasta_base" ]]; then
    log_erro "A pasta '$pasta_base' n√£o existe!"
    printf "üí° Use 'extrair_conteudo --help' para ver as op√ß√µes de uso\n"
    return 1
  fi

  # ===========================[ Resolu√ß√£o do arquivo de sa√≠da ]===================
  # Regras:
  # - Se nome fornecido e for absoluto ou incluir '/', respeita-se o caminho.
  # - Sen√£o, grava em pasta_base/nome
  # - Default: pasta_base/conteudo_arquivos.txt
  local caminho_saida
  if [[ -n "$nome_saida" ]]; then
    if [[ "$nome_saida" = /* || "$nome_saida" == */* ]]; then
      caminho_saida="$nome_saida"
    else
      caminho_saida="$pasta_base/$nome_saida"
    fi
  else
    caminho_saida="$pasta_base/conteudo_arquivos.txt"
  fi
  mkdir -p -- "$(dirname -- "$caminho_saida")"
  rm -f -- "$caminho_saida" 2>/dev/null || true

  # ===============================[ Utilit√°rios ]=================================
  # Caminho absoluto, port√°vel entre macOS/Linux sem 'realpath'/'readlink -f'
  caminho_absoluto() {
    local p="$1"
    (cd "$(dirname -- "$p")" 2>/dev/null && printf '%s/%s\n' "$(pwd -P)" "$(basename -- "$p")")
  }

  # Gera uma linha separadora com largura N, preenchida por um padr√£o (1+ chars)
  linha_separadora() {
    local largura="$1" padrao="$2"
    if [[ ${#padrao} -eq 1 ]]; then
      # Padr√£o unit√°rio ‚Äî mais perform√°tico
      printf '%*s' "$largura" '' | tr ' ' "$padrao"
    else
      # Padr√£o com mais de 1 char ‚Äî repetimos at√© o tamanho desejado
      local out=""
      while [[ ${#out} -lt "$largura" ]]; do out="$out$padrao"; done
      printf '%s\n' "${out:0:$largura}"
    fi
  }

  # Calcula a largura efetiva do separador com base no cabe√ßalho/rodap√© e largura m√≠nima
  calcular_largura_separador() {
    local cab="$1" rod="$2"
    local lcab=${#cab} lrod=${#rod}
    local min="$largura_sep" # largura m√≠nima solicitada
    ((lcab > min)) && min="$lcab"
    ((lrod > min)) && min="$lrod"
    printf '%s\n' "$min"
  }

  # Match de extens√£o (se lista vazia => aceita tudo)
  combina_extensao() {
    local arquivo="$1" ext
    if [[ ${#lista_extensoes[@]} -eq 0 ]]; then return 0; fi
    for ext in "${lista_extensoes[@]}"; do
      [[ "$arquivo" == *"$ext" ]] && return 0
    done
    return 1
  }

  # Verifica se deve excluir o arquivo com base nos padr√µes fornecidos.
  # Retorna 0 (verdadeiro) se DEVE EXCLUIR; retorna 1 se N√ÉO deve.
  deve_excluir() {
    local caminho="$1" base="${1##*/}" padrao
    for padrao in "${lista_exclusoes[@]}"; do
      # Aceita padr√µes/globs; compara com basename e com caminho completo.
      if [[ "$base" == "$padrao" || "$caminho" == "$padrao" || "$caminho" == */"$padrao" ]]; then
        return 0
      fi
    done
    return 1
  }

  # =============================[ Processamento ]=================================
  local total_processados=0

  # Processa um arquivo individual: valida, constr√≥i separadores, apenda ao arquivo de sa√≠da.
  processar_arquivo() {
    local arquivo="$1"
    [[ -f "$arquivo" ]] || return 0

    # Evita processar o pr√≥prio arquivo de sa√≠da (mesmo se via relativo)
    if [[ "$(caminho_absoluto "$arquivo")" == "$(caminho_absoluto "$caminho_saida")" ]]; then
      return 0
    fi

    if deve_excluir "$arquivo"; then
      log_ignorado "Ignorado (--exclude): $(basename -- "$arquivo")"
      return 0
    fi

    [[ -r "$arquivo" ]] || {
      log_aviso "Sem permiss√£o: $(basename -- "$arquivo")"
      return 0
    }

    # Detecta bin√°rio ‚Äî `grep -Iq .` retorna sucesso para arquivo texto
    if ! grep -Iq . -- "$arquivo"; then
      log_aviso "Ignorando bin√°rio: $(basename -- "$arquivo")"
      return 0
    fi

    local caminho_abs
    caminho_abs="$(caminho_absoluto "$arquivo")"
    local cabecalho="INICIO: $caminho_abs"
    local rodape="FIM: $caminho_abs"
    local largura_efetiva
    largura_efetiva="$(calcular_largura_separador "$cabecalho" "$rodape")"
    local separador
    separador="$(linha_separadora "$largura_efetiva" "$padrao_sep")"

    {
      printf '%s\n' "$separador"
      printf '%s\n' "$cabecalho"
      printf '%s\n' "$separador"
      cat -- "$arquivo"
      printf '\n'
      printf '%s\n' "$separador"
      printf '%s\n' "$rodape"
      printf '%s\n' "$separador"
      printf '\n'
    } >>"$caminho_saida"

    ((total_processados++))
    log_sucesso "Processado: $(basename -- "$arquivo")"
  }

  # Descobre e itera arquivos quando N√ÉO h√° uma lista espec√≠fica:
  # Unifica a l√≥gica recursiva e n√£o-recursiva, evitando duplica√ß√£o.
  varrer_pasta() {
    local alvo="$1"  # pasta base
    local f
    if $recursivo; then
      log_info "Processando RECURSIVAMENTE em: $alvo"
      # Sem pipe! O while roda no shell atual; o find alimenta via redire√ß√£o.
      while IFS= read -r -d $'\0' f; do
        deve_excluir "$f" && { log_ignorado "Ignorado (--exclude): $(basename -- "$f")"; continue; }
        combina_extensao "$f" || continue
        processar_arquivo "$f"
      done < <(find "$alvo" -type f -print0)
    else
      log_info "Processando TODOS os arquivos em: $alvo"
      while IFS= read -r -d $'\0' f; do
        deve_excluir "$f" && { log_ignorado "Ignorado (--exclude): $(basename -- "$f")"; continue; }
        combina_extensao "$f" || continue
        processar_arquivo "$f"
      done < <(find "$alvo" -maxdepth 1 -type f -print0)
    fi
  }

  # Trata a lista de arquivos espec√≠ficos ‚Äî mant√©m sem√¢ntica original:
  # - Procura pelo nome literal no cwd e em pasta_base
  # - Se recursivo, tamb√©m busca por basename via find, podendo trazer m√∫ltiplos matches
  processar_especificos() {
    local base="$1"
    shift
    local -a nomes=("$@")
    local nome f encontrado

    log_info "Processando arquivos espec√≠ficos em: $base"
    for nome in "${nomes[@]}"; do
      encontrado=false

      # Candidato 1: caminho passado literalmente
      if [[ -f "$nome" ]] && ! deve_excluir "$nome"; then
        processar_arquivo "$nome"
        encontrado=true
      fi

      # Candidato 2: dentro da pasta base
      if ! $encontrado && [[ -f "$base/$nome" ]] && ! deve_excluir "$base/$nome"; then
        processar_arquivo "$base/$nome"
        encontrado=true
      fi

      # Candidato 3: busca recursiva por basename (se -r)
      if $recursivo && ! $encontrado; then
        local padrao_busca
        padrao_busca="$(basename -- "$nome")"
        # -name casa apenas basename; -print0 para seguran√ßa
        while IFS= read -r -d $'\0' f; do
          deve_excluir "$f" && continue
          processar_arquivo "$f"
          encontrado=true
        done < <(find "$base" -type f -name "$padrao_busca" -print0)
      fi

      $encontrado || log_aviso "'$nome' n√£o encontrado (ou exclu√≠do por --exclude)"
    done
  }

  # ===============================[ Execu√ß√£o ]====================================
  if [[ ${#arquivos_especificos[@]} -eq 0 ]]; then
    # Sem lista espec√≠fica: varre a pasta (com ou sem recurs√£o)
    varrer_pasta "$pasta_base"
  else
    # Com lista espec√≠fica: processa conforme regras acima
    processar_especificos "$pasta_base" "${arquivos_especificos[@]}"
  fi

  # ===============================[ Resultado ]===================================
  if [[ "$total_processados" -eq 0 ]]; then
    log_erro "Nenhum arquivo foi processado"
    rm -f -- "$caminho_saida" 2>/dev/null || true
    printf "üí° Use 'extrair_conteudo --help' para ver as op√ß√µes de uso\n"
  else
    printf 'üéâ Conclu√≠do! %s arquivo(s) processado(s)\n' "$total_processados"
    printf 'üìÑ Conte√∫do salvo em: %s\n' "$caminho_saida"
  fi

  # ==============================[ Limpeza de escopo ]============================
  # Remove fun√ß√µes auxiliares do escopo global do shell do usu√°rio.
  unset -f \
    mostrar_ajuda log_info log_sucesso log_aviso log_erro log_ignorado \
    caminho_absoluto linha_separadora calcular_largura_separador \
    combina_extensao deve_excluir processar_arquivo varrer_pasta processar_especificos
}

# Ponto de entrada ‚Äî chama a fun√ß√£o principal com os argumentos passados
extrair_conteudo "$@"
